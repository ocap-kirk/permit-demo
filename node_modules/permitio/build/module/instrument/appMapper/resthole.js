import _ from 'lodash';
import { KEY_DELIMITER, PATH_DELIMITER } from './mapExpress/mapExpressApp';
/**
 *
 * @param a path
 * @param b path
 * @param pathDelim delimiter
 * @returns the mutual path shared by both a and b
 */
function getPathsSharedBase(a, b, pathDelim = PATH_DELIMITER) {
    const aParts = a.split(pathDelim);
    const bParts = b.split(pathDelim);
    const sharedBase = [];
    const minLength = Math.min(aParts.length, bParts.length);
    // All but last
    for (let i = 0; i <= minLength; ++i) {
        if (aParts[i] !== bParts[i]) {
            break;
        }
        sharedBase.push(aParts[i]);
    }
    // For grouping purposes - paths ending with a key are part of the same path without the key (i.e. '\p\:1' === '\p')
    // drop last path part if it's a key
    const cleanSharedPath = _.join(sharedBase.length > 1 && sharedBase[sharedBase.length - 1].startsWith(KEY_DELIMITER)
        ? sharedBase.slice(0, sharedBase.length - 1)
        : sharedBase, pathDelim);
    return cleanSharedPath;
}
export function groupRestHoleEndpoints(endpoints) {
    const groups = {};
    // Get all EP that have only a single method (REST-HOLE pattern), and sort them longest first
    const singleMethodEndpoints = _.reverse(_.sortBy(_.filter(endpoints, (e) => e?.methods.length === 1), 'path.length'));
    for (const a of singleMethodEndpoints) {
        const sharedPaths = [];
        // Find all endpoints that share a mutual base-path
        for (const b of singleMethodEndpoints) {
            if (a.path !== b.path) {
                const shared = getPathsSharedBase(a.path, b.path);
                if (shared.length > 0) {
                    sharedPaths.push(shared);
                }
            }
        }
        // Keep only the longest paths that don't overlap
        const longestSharedPaths = _.filter(sharedPaths, (path) => {
            // Paths overlapping with the current path which are longer
            const overlappingAndLonger = _.filter(sharedPaths, (otherPath) => path !== otherPath && otherPath.startsWith(path) && otherPath.length > path.length);
            return overlappingAndLonger.length === 0;
        });
        for (const groupPath of longestSharedPaths) {
            const group = _.get(groups, groupPath, {});
            // storing by path ensures uniqueness
            group[a.path] = a;
            groups[groupPath] = group;
        }
    }
    // Flatten and ensure order (shortest first - likely the root node)
    const flatGroups = _.fromPairs(_.map(groups, (group, key) => [key, _.sortBy(_.values(group), 'path')]));
    return flatGroups;
}
/**          const group: MappedEndpoint[] = _.get(groups, shared, []);
          group.push(a);
          groups[shared] = group;
          // Place only in one group (the longest - most specific)
          break; */
/**
 *
 * @param path route path
 * @param groups groups of endpoints
 * @returns the group the path belongs to, or undefined if not found
 */
export function findGroupForPath(path, groups) {
    for (const [name, endpoints] of _.toPairs(groups)) {
        const paths = _.map(endpoints, 'path');
        // If the endpoint is part of a group
        if (_.includes(paths, path)) {
            // mark it
            return { endpoints, name };
        }
    }
    return undefined;
}
/**
 *
 * Heuristic to rename endpoint methods for REST-HOLE; based on last route part
 * update groups in place
 * @returns groups (updated)
 */
export function nameEndpointsInRestHoleGroups(groups) {
    _.forEach(groups, (eps, groupPath) => _.forEach(eps, (ep) => {
        const uniqueParts = _.trim(ep.path.slice(groupPath.length), PATH_DELIMITER);
        // Ignore key/id URL parts
        const nameParts = _.trim(_.join(_.reject(uniqueParts.split(PATH_DELIMITER), (i) => i.startsWith(KEY_DELIMITER)), ' '));
        //
        if (nameParts.length > 0 && ep?.methods.length > 0) {
            ep.namedMethods[ep.methods[0]] = nameParts;
        }
    }));
    return groups;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzdGhvbGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvaW5zdHJ1bWVudC9hcHBNYXBwZXIvcmVzdGhvbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFHM0U7Ozs7OztHQU1HO0FBQ0gsU0FBUyxrQkFBa0IsQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLFNBQVMsR0FBRyxjQUFjO0lBQzFFLE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbEMsTUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNsQyxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7SUFDdEIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN6RCxlQUFlO0lBQ2YsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLFNBQVMsRUFBRSxFQUFFLENBQUMsRUFBRTtRQUNuQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDM0IsTUFBTTtTQUNQO1FBQ0QsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM1QjtJQUNELG9IQUFvSDtJQUNwSCxvQ0FBb0M7SUFDcEMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FDNUIsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FB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