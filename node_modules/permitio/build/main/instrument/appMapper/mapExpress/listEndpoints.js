"use strict";
/**
 * Based on https://github.com/AlbertoFdzM/express-list-endpoints/blob/0b14cc3a5c2a2422d1e3712085203acb4a0b5cfe/src/index.js
 * + additional change to expose the callback function
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
// var debug = require('debug')('express-list-endpoints')
const regexpExpressRegexp = /^\/\^\\\/(?:(:?[\w\\.-]*(?:\\\/:?[\w\\.-]*)*)|(\(\?:\(\[\^\\\/]\+\?\)\)))\\\/.*/;
// var arrayPathItemRegexp = /\^[^^$]*\\\/\?\(\?=\\\/\|\$\)\|?/
// var arrayPathsRegexp = /\(\?:((\^[^^$]*\\\/\?\(\?=\\\/\|\$\)\|?)+)\)\/i?/
const expressRootRegexp = '/^\\/?(?=\\/|$)/i';
const regexpExpressParam = /\(\?:\(\[\^\\\/]\+\?\)\)/g;
const STACK_ITEM_VALID_NAMES = ['router', 'bound dispatch', 'mounted_app'];
/**
 * Returns all the verbs detected for the passed route
 */
const getRouteMethods = function (route) {
    const methods = [];
    for (const method in route.methods) {
        if (method === '_all')
            continue;
        methods.push(method.toUpperCase());
    }
    return methods;
};
/**
 * Returns the names (or anonymous) of all the middleware attached to the
 * passed route
 */
const getRouteMiddleware = function (route) {
    return route.stack.map(function (item) {
        return item.handle || undefined;
    });
};
/**
 * Returns true if found regexp related with express params
 */
const hasParams = function (pathRegexp) {
    return regexpExpressParam.test(pathRegexp);
};
/**
 * Utility function for parseExpressRoute
 */
function parseSingleRoute(route, basePath, path) {
    const methods = getRouteMethods(route);
    const middleware = getRouteMiddleware(route);
    // Actual functions without middleware (middleware comes first)
    const endFunctions = lodash_1.default.slice(middleware, lodash_1.default.size(middleware) - lodash_1.default.size(methods));
    return {
        path: basePath + (basePath && path === '/' ? '' : path),
        methods,
        middleware,
        // layer: layer,
        // route: route,
        namedMethods: lodash_1.default.fromPairs(lodash_1.default.reject(lodash_1.default.zip(methods, lodash_1.default.map(endFunctions, 'name')), ([, v]) => v === undefined)),
        methodToCallable: lodash_1.default.fromPairs(lodash_1.default.zip(methods, endFunctions)),
    };
}
/**
 * @param {Object} route Express route object to be parsed
 * @param {string} basePath The basePath the route is on
 * @param {Object} layer The layer that  wraps the route
 * @return {Object[]} Endpoints info
 */
const parseExpressRoute = function (route, basePath) {
    const endpoints = [];
    if (Array.isArray(route.path)) {
        route.path.forEach(function (path) {
            const endpoint = parseSingleRoute(route, basePath, path);
            endpoints.push(endpoint);
        });
    }
    else {
        const endpoint = parseSingleRoute(route, basePath, route.path);
        endpoints.push(endpoint);
    }
    return endpoints;
};
const parseExpressPath = function (expressPathRegexp, params) {
    let parsedPath = regexpExpressRegexp.exec(expressPathRegexp);
    let parsedRegexp = expressPathRegexp;
    let paramIdx = 0;
    while (hasParams(parsedRegexp)) {
        const paramId = ':' + params[paramIdx].name;
        parsedRegexp = parsedRegexp.toString().replace(/\(\?:\(\[\^\\\/]\+\?\)\)/, paramId);
        paramIdx++;
    }
    if (parsedRegexp !== expressPathRegexp) {
        parsedPath = regexpExpressRegexp.exec(parsedRegexp);
    }
    parsedPath = parsedPath[1].replace(/\\\//g, '/');
    return parsedPath;
};
const parseEndpoints = function (app, basePath, endpoints) {
    const stack = app.stack || (app._router && app._router.stack);
    endpoints = endpoints || [];
    basePath = basePath || '';
    if (!stack) {
        addEndpoints(endpoints, [
            {
                path: basePath,
                methods: [],
                middleware: [],
            },
        ]);
    }
    else {
        stack.forEach(function (stackItem) {
            if (stackItem.route) {
                const newEndpoints = parseExpressRoute(stackItem.route, basePath);
                endpoints = addEndpoints(endpoints, newEndpoints);
            }
            else if (STACK_ITEM_VALID_NAMES.indexOf(stackItem.name) > -1) {
                if (regexpExpressRegexp.test(stackItem.regexp)) {
                    const parsedPath = parseExpressPath(stackItem.regexp, stackItem.keys);
                    parseEndpoints(stackItem.handle, basePath + '/' + parsedPath, endpoints);
                }
                else if (!stackItem.path &&
                    stackItem.regexp &&
                    stackItem.regexp.toString() !== expressRootRegexp) {
                    const regEcpPath = ' RegExp(' + stackItem.regexp + ') ';
                    parseEndpoints(stackItem.handle, basePath + '/' + regEcpPath, endpoints);
                }
                else {
                    parseEndpoints(stackItem.handle, basePath, endpoints);
                }
            }
        });
    }
    return endpoints;
};
/**
 * Ensures the path of the new endpoints isn't yet in the array.
 * If the path is already in the array merges the endpoints with the existing
 * one, if not, it adds them to the array.
 *
 * @param {Array} endpoints Array of current endpoints
 * @param {Object[]} newEndpoints New endpoints to be added to the array
 * @returns {Array} Updated endpoints array
 */
const addEndpoints = function (endpoints, newEndpoints) {
    newEndpoints.forEach(function (newEndpoint) {
        const foundEndpointIdx = endpoints.findIndex(function (item) {
            return item.path === newEndpoint.path;
        });
        if (foundEndpointIdx > -1) {
            const foundEndpoint = endpoints[foundEndpointIdx];
            const newMethods = newEndpoint.methods.filter(function (method) {
                return foundEndpoint.methods.indexOf(method) === -1;
            });
            const newMiddleware = newEndpoint.middleware.filter(function (middleware) {
                return foundEndpoint.middleware.indexOf(middleware) === -1;
            });
            foundEndpoint.methods = foundEndpoint.methods.concat(newMethods);
            foundEndpoint.middleware = foundEndpoint.middleware.concat(newMiddleware);
            foundEndpoint.namedMethods = lodash_1.default.assign(foundEndpoint.namedMethods, newEndpoint.namedMethods);
            foundEndpoint.methodToCallable = lodash_1.default.assign(foundEndpoint.methodToCallable, newEndpoint.methodToCallable);
        }
        else {
            endpoints.push(newEndpoint);
        }
    });
    return endpoints;
};
/**
 * Returns an array of strings with all the detected endpoints
 * @param {Object} app the express/route instance to get the endpoints from
 */
const getEndpoints = function (app) {
    const endpoints = parseEndpoints(app);
    return endpoints;
};
exports.default = getEndpoints;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlzdEVuZHBvaW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9pbnN0cnVtZW50L2FwcE1hcHBlci9tYXBFeHByZXNzL2xpc3RFbmRwb2ludHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7Ozs7QUFFSCxvREFBdUI7QUFFdkIseURBQXlEO0FBQ3pELE1BQU0sbUJBQW1CLEdBQ3ZCLGlGQUFpRixDQUFDO0FBQ3BGLCtEQUErRDtBQUMvRCw0RUFBNEU7QUFDNUUsTUFBTSxpQkFBaUIsR0FBRyxtQkFBbUIsQ0FBQztBQUM5QyxNQUFNLGtCQUFrQixHQUFHLDJCQUEyQixDQUFDO0FBRXZELE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFFM0U7O0dBRUc7QUFDSCxNQUFNLGVBQWUsR0FBRyxVQUFVLEtBQVU7SUFDMUMsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBRW5CLEtBQUssTUFBTSxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRTtRQUNsQyxJQUFJLE1BQU0sS0FBSyxNQUFNO1lBQUUsU0FBUztRQUVoQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0tBQ3BDO0lBRUQsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsTUFBTSxrQkFBa0IsR0FBRyxVQUFVLEtBQXVCO0lBQzFELE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxJQUErQjtRQUM5RCxPQUFPLElBQUksQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDO0lBQ2xDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDO0FBRUY7O0dBRUc7QUFDSCxNQUFNLFNBQVMsR0FBRyxVQUFVLFVBQWtCO0lBQzVDLE9BQU8sa0JBQWtCLENBQUMsSUFBSSxDQUFD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